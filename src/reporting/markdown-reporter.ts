import type { CheckExecution, RepositoryReport, RunnerReport } from '../runner/types';

export class MarkdownReporter {
  /**
   * Generate a markdown report from runner results
   */
  generateReport(report: RunnerReport): string {
    const lines: string[] = [];

    // Header
    lines.push('# GitHub Compliance Report');
    lines.push('');
    lines.push(`**Generated:** ${new Date(report.timestamp).toLocaleString()}`);
    lines.push(`**Execution Time:** ${(report.executionTime / 1000).toFixed(2)} seconds`);
    lines.push('');

    // Summary Statistics
    lines.push('## Summary');
    lines.push('');
    lines.push('| Metric | Count | Percentage |');
    lines.push('|--------|-------|------------|');
    lines.push(`| **Total Repositories** | ${report.totalRepositories} | 100% |`);
    lines.push(
      `| ✅ Compliant | ${report.compliantRepositories} | ${this.percentage(report.compliantRepositories, report.totalRepositories)}% |`
    );
    lines.push(
      `| ❌ Non-Compliant | ${report.nonCompliantRepositories} | ${this.percentage(report.nonCompliantRepositories, report.totalRepositories)}% |`
    );
    lines.push(
      `| 🔧 Fixed | ${report.fixedRepositories} | ${this.percentage(report.fixedRepositories, report.totalRepositories)}% |`
    );
    lines.push(
      `| ⚠️ Errors | ${report.errorRepositories} | ${this.percentage(report.errorRepositories, report.totalRepositories)}% |`
    );
    lines.push('');
    lines.push(`**Overall Compliance Rate:** ${report.compliancePercentage}%`);
    lines.push('');

    // Non-compliant repositories details
    const nonCompliant = report.repositories.filter((r) => !r.compliant);
    if (nonCompliant.length > 0) {
      lines.push('## Non-Compliant Repositories');
      lines.push('');
      lines.push('| Repository | Status | Failed Checks | Details |');
      lines.push('|------------|--------|---------------|---------|');

      for (const repo of nonCompliant) {
        const failedChecks = repo.checks.filter((c) => !c.result.compliant && !c.result.fixed);
        const errorChecks = repo.checks.filter((c) => c.result.error);

        const status = errorChecks.length > 0 ? '⚠️ Error' : '❌ Failed';
        const details = this.getRepoStatusDetails(repo);

        lines.push(
          `| **${repo.repository.full_name}** | ${status} | ${failedChecks.length} | ${details} |`
        );
      }
      lines.push('');
    }

    // Detailed results by repository
    lines.push('## Detailed Results');
    lines.push('');

    for (const repo of report.repositories) {
      lines.push(`### ${repo.repository.full_name}`);
      lines.push('');
      lines.push(`- **Status:** ${repo.compliant ? '✅ Compliant' : '❌ Non-Compliant'}`);
      lines.push(
        `- **Type:** ${repo.repository.private ? 'Private' : 'Public'} ${repo.repository.archived ? '(Archived)' : ''}`
      );
      lines.push(`- **Checks Run:** ${repo.checksRun}`);
      lines.push(
        `- **Results:** ${repo.checksPassed} passed, ${repo.checksFailed} failed, ${repo.checksFixed} fixed, ${repo.checksErrored} errors`
      );
      lines.push('');

      if (repo.checks.length > 0) {
        lines.push('#### Check Results');
        lines.push('');
        lines.push('| Check | Status | Message | Duration |');
        lines.push('|-------|--------|---------|----------|');

        for (const check of repo.checks) {
          const status = this.getCheckStatus(check);
          const duration = `${check.duration}ms`;
          const message = this.truncate(check.result.message, 50);

          lines.push(`| ${check.checkName} | ${status} | ${message} | ${duration} |`);
        }
        lines.push('');
      }
    }

    // Recommendations
    lines.push('## Recommendations');
    lines.push('');

    if (report.nonCompliantRepositories > 0) {
      lines.push('1. Review and fix non-compliant repositories');
      lines.push('2. Consider running with `--fix` flag to auto-remediate issues');
      lines.push('3. Update repository configurations to match compliance standards');
    } else {
      lines.push('✅ All repositories are compliant with the defined standards!');
    }
    lines.push('');

    // Footer
    lines.push('---');
    lines.push('*Report generated by GitHub Compliance Action*');

    return lines.join('\n');
  }

  /**
   * Generate a summary for GitHub Actions
   */
  generateSummary(report: RunnerReport): string {
    const lines: string[] = [];

    lines.push('## 📊 Compliance Check Results');
    lines.push('');

    // Quick stats
    lines.push(`### ${report.compliancePercentage}% Compliant`);
    lines.push('');
    lines.push(`- ✅ **${report.compliantRepositories}** compliant repositories`);
    lines.push(`- ❌ **${report.nonCompliantRepositories}** non-compliant repositories`);

    if (report.fixedRepositories > 0) {
      lines.push(`- 🔧 **${report.fixedRepositories}** repositories fixed`);
    }

    if (report.errorRepositories > 0) {
      lines.push(`- ⚠️ **${report.errorRepositories}** repositories with errors`);
    }
    lines.push('');

    // Non-compliant list
    const nonCompliant = report.repositories.filter((r) => !r.compliant);
    if (nonCompliant.length > 0) {
      lines.push('### ❌ Non-Compliant Repositories');
      lines.push('');

      for (const repo of nonCompliant.slice(0, 10)) {
        // Limit to top 10 for summary
        const failedChecks = repo.checks
          .filter((c) => !c.result.compliant && !c.result.fixed)
          .map((c) => c.checkName)
          .join(', ');

        lines.push(`- **${repo.repository.full_name}**: ${failedChecks}`);
      }

      if (nonCompliant.length > 10) {
        lines.push(`- ... and ${nonCompliant.length - 10} more`);
      }
    } else {
      lines.push('### ✅ All repositories are compliant!');
    }

    return lines.join('\n');
  }

  private getCheckStatus(check: CheckExecution): string {
    if (check.result.error) {
      return '⚠️ Error';
    }
    if (check.result.fixed) {
      return '🔧 Fixed';
    }
    if (check.result.compliant) {
      return '✅ Pass';
    }
    return '❌ Fail';
  }

  private getRepoStatusDetails(repo: RepositoryReport): string {
    const parts: string[] = [];

    if (repo.checksPassed > 0) {
      parts.push(`${repo.checksPassed} passed`);
    }
    if (repo.checksFailed > 0) {
      parts.push(`${repo.checksFailed} failed`);
    }
    if (repo.checksFixed > 0) {
      parts.push(`${repo.checksFixed} fixed`);
    }
    if (repo.checksErrored > 0) {
      parts.push(`${repo.checksErrored} errors`);
    }

    return parts.join(', ');
  }

  private percentage(value: number, total: number): number {
    if (total === 0) return 0;
    return Math.round((value / total) * 100);
  }

  private truncate(text: string, maxLength: number): string {
    if (text.length <= maxLength) return text;
    return `${text.substring(0, maxLength - 3)}...`;
  }
}
